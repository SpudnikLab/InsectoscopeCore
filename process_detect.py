# -*- coding: utf-8 -*-
"""process_detect.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tS-tQejewxbBGhHgx8IwLi1MLYr3uc5B
"""

import concurrent.futures
import numpy as np
from python_speech_features import mfcc
from python_speech_features import delta
from scipy.spatial.distance import euclidean
import os
import io
import pandas as pd
import concurrent.futures
from scipy.io import wavfile
import time
import json
import soundfile as sf
from googleapiclient.http import MediaFileUpload, MediaIoBaseDownload
from AuthDrive import create_drive_service


# Function to read CSV data
def read_csv(file_path):
    return pd.read_csv(file_path)

# Function to load audio from file
# def load_audio(audio_file):
#     return wavfile.read(audio_file)

def load_audio_from_gdrive(service, file_id):
    print("id file:",file_id)
    # request = service.files().get_media(fileId='11hwHojOYhPeU6_gZi052xNjjnp1IvqVA')
    request = service.files().get_media(fileId=file_id)
    fh = io.BytesIO()
    downloader = MediaIoBaseDownload(fh, request)
    done = False
    while not done:
        status, done = downloader.next_chunk()
    fh.seek(0)
    return wavfile.read(fh)


def match_audio_files(service, csv_data, gdrive_folder_id):
    id_to_audio = {}
    query = f"'{gdrive_folder_id}' in parents"
    results = service.files().list(q=query, fields="files(id, name)").execute()
    items = results.get('files', [])

    # Membuat set dari nama file di folder Google Drive
    audio_files_set = {item['name'] for item in items}

    for index, row in csv_data.iterrows():
        audio_file_name = f"{row['id']}.wav"
        # Memeriksa apakah nama file audio ada dalam folder Google Drive
        if audio_file_name in audio_files_set:
            # Jika ada, tambahkan ke id_to_audio
            id_to_audio[row['id']] = [item['id'] for item in items if item['name'] == audio_file_name][0]

    return id_to_audio

def compare_audio(new_audio_path, existing_audios, method='mfcc'):
    if not os.path.exists(new_audio_path):
        return False, False, False

    new_sr, new_audio = wavfile.read(new_audio_path)
    min_distance = float('inf')
    closest_match_id = None

    # Calculate MFCC for the new audio
    new_mfcc = mfcc(new_audio, samplerate=new_sr)

    # Define a helper function for calculating similarity
    def calculate_similarity(existing_id, existing_audio_data):
        existing_sr, existing_audio = existing_audio_data
        existing_mfcc = mfcc(existing_audio, samplerate=existing_sr)
        similarity = euclidean(new_mfcc.mean(axis=0), existing_mfcc.mean(axis=0))
        return existing_id, similarity

    # Iterate over existing audios
    with concurrent.futures.ThreadPoolExecutor() as executor:
        similarity_results = list(executor.map(lambda x: calculate_similarity(*x), existing_audios.items()))

    for id_, similarity in similarity_results:
        print("ID: {id_}.similarity:",similarity)
        if similarity == 0.0:
            min_distance = similarity
            closest_match_id = id_
            break
        elif similarity < min_distance:
            min_distance = similarity
            closest_match_id = id_

    return closest_match_id, min_distance, new_audio, new_sr

def extract_features(audio_path):
    # Load audio file
    y, sr = sf.read(audio_path)

    # Extract MFCCs
    mfccs = mfcc(y, samplerate=sr, numcep=40)  # Using 40 MFCCs
    delta_mfccs = delta(mfccs, 2)  # Include delta coefficients
    delta_delta_mfccs = delta(delta_mfccs, 2)  # Include delta-delta coefficients

    # Concatenate all coefficients
    all_mfccs = np.concatenate((mfccs, delta_mfccs, delta_delta_mfccs), axis=1)

    # Compute statistical features from MFCCs
    mfccs_mean = np.mean(all_mfccs, axis=0)
    mfccs_std = np.std(all_mfccs, axis=0)

    # Concatenate mean and standard deviation to form feature vector
    features = np.concatenate((mfccs_mean, mfccs_std))

    return features

def classify_sound(audio_path):
    # Extract features from the audio
    features = extract_features(audio_path)

    # Define thresholds for distinguishing between human and mosquito sounds
    # Example thresholds, adjust as needed based on your data
    threshold = 1

    # Apply simple rules to classify the sound
    resultAverage = np.mean(features)
    print(resultAverage)
    if resultAverage > threshold:
        return "Audio"
    elif resultAverage < threshold:
        return "Mosquito"

# 1. Membaca data1.csv dan mencari nilai species untuk id 57
def find_species_for_id(file_path, id_value):
    df = pd.read_csv(file_path)
    species_value = df.loc[df['id'] == id_value, 'species'].iloc[0]
    return species_value

def find_data_for_species(file_path, species_name):
    df = pd.read_csv(file_path)
    result = df.loc[df['Species Name'] == species_name, ['Species Name', 'Disease', 'Danger Level']]
    return result.values.tolist()[0] if not result.empty else None

def processDetect(unique_filename):
    start_time = time.time()

    # CSV file location and audio directory
    csv_file = r"E:\KERJA\spudniklab\InsecstopProjeck\data\metadata\data.csv"
    csv_dangerous_species = r"E:\KERJA\spudniklab\InsecstopProjeck\data\metadata\dangerous_species.csv"
    credential_info = r"E:\KERJA\spudniklab\InsectoscopeProjeckAPI\data\metadata\serviceaccount.json"
    
    # Live
    # csv_file = os.path.join(os.path.dirname(__file__), 'data', 'metadata', 'data.csv')
    # csv_dangerous_species = os.path.join(os.path.dirname(__file__), 'data', 'metadata', 'dangerous_species.csv')
    # credential_info = os.path.join(os.path.dirname(__file__), 'data', 'metadata', 'cred.json')
    
    service = create_drive_service(credential_info)
    
    # gdrive folder id
    gdrive_folder_id = '1vL57mbDfYfchxI0o5i-CnPwDhqXPbITh'

    # Read data from CSV
    csv_data = read_csv(csv_file)

    # Cocokkan ID dengan nama file audio di Google Drive
    id_to_audio = match_audio_files(service, csv_data, gdrive_folder_id)

    print(id_to_audio.items())
    # Proses audio secara paralel
    with concurrent.futures.ThreadPoolExecutor() as executor:
        audio_data = {id_: executor.submit(load_audio_from_gdrive, service, audio_file).result() for id_, audio_file in id_to_audio.items()}


    # Example of new audio
    #lokal
    # new_audio_path = os.path.join(r"E:\KERJA\spudniklab\InsectoscopeProjeckAPI\upload", unique_filename)

    # Live
    upload_folder = os.path.join(os.path.dirname(__file__), 'upload')
    new_audio_path = os.path.join(upload_folder, unique_filename)
    
    #check sound tyep
    checkSoundtype = classify_sound(new_audio_path)

    print("Sound Type :",checkSoundtype)
    if checkSoundtype == "Audio":
        return json.dumps({"speciesName": "", "similarityValue": 0, "check_dangerous": "", "status": "Sound Type:Audio", "process":"completed"})


    # Compare new audio with existing audio
    closest_match_id,similarity,new_audio, new_sr = compare_audio(new_audio_path, audio_data)


    if closest_match_id is False:
        return json.dumps({"speciesName": "", "similarityValue": 0, "check_dangerous": "", "status": "file not found","process":"completed"})


    print("Similarity value:",similarity)
    if closest_match_id:
        print(f"New audio is similar to the species with ID: {closest_match_id}.")
         # Check dangerous or not
        get_speciesname = find_species_for_id(csv_file, closest_match_id)
        print(f"Species untuk ID {closest_match_id}:", get_speciesname)

        check_dangerous = find_data_for_species(csv_dangerous_species, get_speciesname)

        if similarity == 0.0:
            precentageSimilarity = 100
        else:
            precentageSimilarity = round(similarity)+30

        if precentageSimilarity > 100:
            precentageSimilarity = 100
        elif precentageSimilarity < 40:
            return json.dumps({"speciesName": "", "similarityValue": 0, "check_dangerous": "", "status": "Species not found", "process":"completed"})

        print("Percentage Similarity value:",precentageSimilarity)

        if check_dangerous:
            print("Species DANGEROUS", get_speciesname, ":", check_dangerous)
            return json.dumps({"speciesName": get_speciesname, "similarityValue": precentageSimilarity, "check_dangerous": check_dangerous, "status": "Species found", "process":"completed"})
        else:
            print("Species NOT DANGEROUS ")
            return json.dumps({"speciesName": get_speciesname, "similarityValue": precentageSimilarity, "check_dangerous": "Low", "status": "Species found", "process":"completed"})

    else:
        print("No matching species found.")

        return json.dumps({"speciesName": "", "similarityValue": 0, "check_dangerous": "", "status": "Species not found", "process":"completed"})

    print("Total time:", time.time() - start_time)

# if __name__ == "__main__":
#     processDetect("81.wav")