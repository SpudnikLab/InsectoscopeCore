# -*- coding: utf-8 -*-
"""process_detect.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MZ1j7bBdOFN3LBaMjoTSSzj41eICEEQh
"""

import numpy as np
from python_speech_features import mfcc
from scipy.spatial.distance import euclidean
import os
import pandas as pd
import concurrent.futures
from scipy.io import wavfile
from scipy.spatial.distance import cosine
import time
from matplotlib.colors import LogNorm



# Function to read CSV data
def read_csv(file_path):
    return pd.read_csv(file_path)

# Function to load audio from file
def load_audio(audio_file):
    return wavfile.read(audio_file)

# Function to match IDs with audio file names
def match_audio_files(csv_data, audio_dir):
    id_to_audio = {}
    for index, row in csv_data.iterrows():
        audio_file = os.path.join(audio_dir, f"{row['id']}.wav")
        if os.path.exists(audio_file):
            id_to_audio[row['id']] = audio_file
    return id_to_audio

def compare_audio(new_audio_path, existing_audios, method='mfcc'):
    if not os.path.exists(new_audio_path):

        return False, False, False

    new_sr, new_audio = wavfile.read(new_audio_path)
    min_distance = float('inf')
    closest_match_id = None

    # Calculate MFCC for the new audio
    new_mfcc = mfcc(new_audio, samplerate=new_sr)

    # Iterate over existing audios
    for id_, (existing_sr, existing_audio) in existing_audios.items():
        # Check if sample rates are compatible

        # if new_sr == existing_sr:
            # Calculate MFCC for the existing audio
            existing_mfcc = mfcc(existing_audio, samplerate=existing_sr)

            # Calculate similarity between the new audio and existing audio
            if method == 'mfcc':
                # Euclidean distance between MFCC vectors
                similarity = euclidean(new_mfcc.mean(axis=0), existing_mfcc.mean(axis=0))
            # Add other methods here as needed

            else:
                raise ValueError("Invalid method specified.")

            # If similarity is high enough, consider the audios as matching
            if 60 < similarity < 62:  # Example threshold, adjust as needed
            # if similarity > 60:
                print("similarity :",similarity)
                closest_match_id = id_
                break
            elif similarity < 19:
                closest_match_id = id_
                break


    return closest_match_id,similarity,new_audio, new_sr

# # Function to plot spectrogram
# def plot_spectrogram(audio, sr, title):
#     plt.figure(figsize=(10, 4))
#     # Flatten the audio signal if it's multi-dimensional
#     if len(audio.shape) > 1:
#         audio = audio.flatten()
#     plt.specgram(audio, Fs=sr, cmap='viridis', NFFT=1024, noverlap=512, scale='dB')
#     plt.title(title)
#     plt.xlabel('Time (s)')
#     plt.ylabel('Frequency (Hz)')
#     plt.colorbar(label='Intensity (dB)')
#     plt.show()

# 1. Membaca data1.csv dan mencari nilai species untuk id 57
def find_species_for_id(file_path, id_value):
    df = pd.read_csv(file_path)
    species_value = df.loc[df['id'] == id_value, 'species'].iloc[0]
    return species_value

def find_data_for_species(file_path, species_name):
    df = pd.read_csv(file_path)
    result = df.loc[df['Species Name'] == species_name, ['Species Name', 'Disease', 'Danger Level']]
    return result.values.tolist()[0] if not result.empty else None

import json


def processDetect(unique_filename):
    start_time = time.time()

    # CSV file location and audio directory
    csv_file = r"E:\KERJA\spudniklab\InsecstopProjeck\data\metadata\data.csv"
    csv_dangerous_species = r"E:\KERJA\spudniklab\InsecstopProjeck\data\metadata\dangerous_species.csv"
    audio_dir = r"E:\KERJA\spudniklab\InsecstopProjeck\data\audio"

    # Read data from CSV
    csv_data = read_csv(csv_file)

    # Match IDs with audio file names
    id_to_audio = match_audio_files(csv_data, audio_dir)

    # Process audio in parallel
    with concurrent.futures.ProcessPoolExecutor() as executor:
        audio_data = {id_: load_audio(audio_file) for id_, audio_file in id_to_audio.items()}

    # Example of new audio
    new_audio_path = os.path.join(r"E:\KERJA\spudniklab\InsecstopProjeck\upload", unique_filename)

    # Compare new audio with existing audio
    closest_match_id,similarity,new_audio, new_sr = compare_audio(new_audio_path, audio_data)

    print("Similarity value:",similarity)
    if closest_match_id is False:
        return print("File not found.")

    # Plot spectrogram of new audio
    print("Spectogram Audio Upload New")
    # plot_spectrogram(new_audio, new_sr, 'New Audio Spectrogram')

    if closest_match_id:
        print(f"New audio is similar to the species with ID: {closest_match_id}.")
        # Check dangerous or not
        get_speciesname = find_species_for_id(csv_file, closest_match_id)
        print(f"Species untuk ID {closest_match_id}:", get_speciesname)

        check_dangerous = find_data_for_species(csv_dangerous_species, get_speciesname)
        if check_dangerous:
            print("Species DANGEROUS", get_speciesname, ":", check_dangerous)
            return json.dumps({"speciesName": get_speciesname, "similarityValue": similarity, "check_dangerous": check_dangerous, "status": "Species found"})
        else:
            print("Species NOT DANGEROUS ")
            return json.dumps({"speciesName": get_speciesname, "similarityValue": similarity, "check_dangerous": "Low", "status": "Species found"})

        # Plot spectrogram of the closest matching audio
        closest_match_audio = audio_data[closest_match_id][1]
        closest_match_sr = audio_data[closest_match_id][0]

        plot_spectrogram(closest_match_audio, closest_match_sr, f'Closest Match ({closest_match_id}) Spectrogram')
    else:
        print("No matching species found.")
        # Jika tidak ada kecocokan, tampilkan spektrogram untuk setiap audio dalam data CSV
        for id_, audio_info in audio_data.items():
            closest_match_audio = audio_data[id_][1]
            closest_match_sr = audio_data[id_][0]

            # plot_spectrogram(closest_match_audio, closest_match_sr, f'Closest Match ({id_}) Spectrogram')
        return json.dumps({"speciesName": "", "similarityValue": 0, "check_dangerous": "", "status": "Species not found"})

    print("Total time:", time.time() - start_time)

# if __name__ == "__main__":
#     processDetect("72.wav")